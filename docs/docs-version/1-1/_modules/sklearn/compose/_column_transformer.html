
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sklearn.compose._column_transformer &#8212; sklearndf  documentation</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/gamma.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/gamma.js"></script>
    <script src="../../../_static/js/versions.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../../index.html">
    
      <img src="../../../_static/gamma_sklearndf_logo.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../getting_started/getting_started.html">Getting started</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../apidoc/sklearndf.html">API reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../tutorials.html">Tutorials</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../contribution_guide.html">Development Guidelines</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../faqs.html">FAQ</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../release_notes.html">Release Notes</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for sklearn.compose._column_transformer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The :mod:`sklearn.compose._column_transformer` module implements utilities</span>
<span class="sd">to work with heterogeneous data and to apply different transformers to</span>
<span class="sd">different columns.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Author: Andreas Mueller</span>
<span class="c1">#         Joris Van den Bossche</span>
<span class="c1"># License: BSD</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="kn">from</span> <span class="nn">..base</span> <span class="kn">import</span> <span class="n">clone</span><span class="p">,</span> <span class="n">TransformerMixin</span>
<span class="kn">from</span> <span class="nn">..utils._estimator_html_repr</span> <span class="kn">import</span> <span class="n">_VisualBlock</span>
<span class="kn">from</span> <span class="nn">..pipeline</span> <span class="kn">import</span> <span class="n">_fit_transform_one</span><span class="p">,</span> <span class="n">_transform_one</span><span class="p">,</span> <span class="n">_name_estimators</span>
<span class="kn">from</span> <span class="nn">..preprocessing</span> <span class="kn">import</span> <span class="n">FunctionTransformer</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">_safe_indexing</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">_get_column_indices</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">_determine_key_type</span>
<span class="kn">from</span> <span class="nn">..utils.metaestimators</span> <span class="kn">import</span> <span class="n">_BaseComposition</span>
<span class="kn">from</span> <span class="nn">..utils.validation</span> <span class="kn">import</span> <span class="n">check_array</span><span class="p">,</span> <span class="n">check_is_fitted</span>
<span class="kn">from</span> <span class="nn">..utils.validation</span> <span class="kn">import</span> <span class="n">_deprecate_positional_args</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;ColumnTransformer&#39;</span><span class="p">,</span> <span class="s1">&#39;make_column_transformer&#39;</span><span class="p">,</span> <span class="s1">&#39;make_column_selector&#39;</span>
<span class="p">]</span>


<span class="n">_ERR_MSG_1DCOLUMN</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;1D data passed to a transformer that expects 2D data. &quot;</span>
                     <span class="s2">&quot;Try to specify the column selection as a list of one &quot;</span>
                     <span class="s2">&quot;item instead of a scalar.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ColumnTransformer</span><span class="p">(</span><span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">_BaseComposition</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies transformers to columns of an array or pandas DataFrame.</span>

<span class="sd">    This estimator allows different columns or column subsets of the input</span>
<span class="sd">    to be transformed separately and the features generated by each transformer</span>
<span class="sd">    will be concatenated to form a single feature space.</span>
<span class="sd">    This is useful for heterogeneous or columnar data, to combine several</span>
<span class="sd">    feature extraction mechanisms or transformations into a single transformer.</span>

<span class="sd">    Read more in the :ref:`User Guide &lt;column_transformer&gt;`.</span>

<span class="sd">    .. versionadded:: 0.20</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transformers : list of tuples</span>
<span class="sd">        List of (name, transformer, columns) tuples specifying the</span>
<span class="sd">        transformer objects to be applied to subsets of the data.</span>

<span class="sd">        name : str</span>
<span class="sd">            Like in Pipeline and FeatureUnion, this allows the transformer and</span>
<span class="sd">            its parameters to be set using ``set_params`` and searched in grid</span>
<span class="sd">            search.</span>
<span class="sd">        transformer : {&#39;drop&#39;, &#39;passthrough&#39;} or estimator</span>
<span class="sd">            Estimator must support :term:`fit` and :term:`transform`.</span>
<span class="sd">            Special-cased strings &#39;drop&#39; and &#39;passthrough&#39; are accepted as</span>
<span class="sd">            well, to indicate to drop the columns or to pass them through</span>
<span class="sd">            untransformed, respectively.</span>
<span class="sd">        columns :  str, array-like of str, int, array-like of int, \</span>
<span class="sd">                array-like of bool, slice or callable</span>
<span class="sd">            Indexes the data on its second axis. Integers are interpreted as</span>
<span class="sd">            positional columns, while strings can reference DataFrame columns</span>
<span class="sd">            by name.  A scalar string or int should be used where</span>
<span class="sd">            ``transformer`` expects X to be a 1d array-like (vector),</span>
<span class="sd">            otherwise a 2d array will be passed to the transformer.</span>
<span class="sd">            A callable is passed the input data `X` and can return any of the</span>
<span class="sd">            above. To select multiple columns by name or dtype, you can use</span>
<span class="sd">            :obj:`make_column_selector`.</span>

<span class="sd">    remainder : {&#39;drop&#39;, &#39;passthrough&#39;} or estimator, default=&#39;drop&#39;</span>
<span class="sd">        By default, only the specified columns in `transformers` are</span>
<span class="sd">        transformed and combined in the output, and the non-specified</span>
<span class="sd">        columns are dropped. (default of ``&#39;drop&#39;``).</span>
<span class="sd">        By specifying ``remainder=&#39;passthrough&#39;``, all remaining columns that</span>
<span class="sd">        were not specified in `transformers` will be automatically passed</span>
<span class="sd">        through. This subset of columns is concatenated with the output of</span>
<span class="sd">        the transformers.</span>
<span class="sd">        By setting ``remainder`` to be an estimator, the remaining</span>
<span class="sd">        non-specified columns will use the ``remainder`` estimator. The</span>
<span class="sd">        estimator must support :term:`fit` and :term:`transform`.</span>
<span class="sd">        Note that using this feature requires that the DataFrame columns</span>
<span class="sd">        input at :term:`fit` and :term:`transform` have identical order.</span>

<span class="sd">    sparse_threshold : float, default=0.3</span>
<span class="sd">        If the output of the different transformers contains sparse matrices,</span>
<span class="sd">        these will be stacked as a sparse matrix if the overall density is</span>
<span class="sd">        lower than this value. Use ``sparse_threshold=0`` to always return</span>
<span class="sd">        dense.  When the transformed output consists of all dense data, the</span>
<span class="sd">        stacked result will be dense, and this keyword will be ignored.</span>

<span class="sd">    n_jobs : int, default=None</span>
<span class="sd">        Number of jobs to run in parallel.</span>
<span class="sd">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span>
<span class="sd">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span>
<span class="sd">        for more details.</span>

<span class="sd">    transformer_weights : dict, default=None</span>
<span class="sd">        Multiplicative weights for features per transformer. The output of the</span>
<span class="sd">        transformer is multiplied by these weights. Keys are transformer names,</span>
<span class="sd">        values the weights.</span>

<span class="sd">    verbose : bool, default=False</span>
<span class="sd">        If True, the time elapsed while fitting each transformer will be</span>
<span class="sd">        printed as it is completed.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    transformers_ : list</span>
<span class="sd">        The collection of fitted transformers as tuples of</span>
<span class="sd">        (name, fitted_transformer, column). `fitted_transformer` can be an</span>
<span class="sd">        estimator, &#39;drop&#39;, or &#39;passthrough&#39;. In case there were no columns</span>
<span class="sd">        selected, this will be the unfitted transformer.</span>
<span class="sd">        If there are remaining columns, the final element is a tuple of the</span>
<span class="sd">        form:</span>
<span class="sd">        (&#39;remainder&#39;, transformer, remaining_columns) corresponding to the</span>
<span class="sd">        ``remainder`` parameter. If there are remaining columns, then</span>
<span class="sd">        ``len(transformers_)==len(transformers)+1``, otherwise</span>
<span class="sd">        ``len(transformers_)==len(transformers)``.</span>

<span class="sd">    named_transformers_ : :class:`~sklearn.utils.Bunch`</span>
<span class="sd">        Read-only attribute to access any transformer by given name.</span>
<span class="sd">        Keys are transformer names and values are the fitted transformer</span>
<span class="sd">        objects.</span>

<span class="sd">    sparse_output_ : bool</span>
<span class="sd">        Boolean flag indicating whether the output of ``transform`` is a</span>
<span class="sd">        sparse matrix or a dense numpy array, which depends on the output</span>
<span class="sd">        of the individual transformers and the `sparse_threshold` keyword.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The order of the columns in the transformed feature matrix follows the</span>
<span class="sd">    order of how the columns are specified in the `transformers` list.</span>
<span class="sd">    Columns of the original feature matrix that are not specified are</span>
<span class="sd">    dropped from the resulting transformed feature matrix, unless specified</span>
<span class="sd">    in the `passthrough` keyword. Those columns specified with `passthrough`</span>
<span class="sd">    are added at the right to the output of the transformers.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.compose.make_column_transformer : convenience function for</span>
<span class="sd">        combining the outputs of multiple transformer objects applied to</span>
<span class="sd">        column subsets of the original feature space.</span>
<span class="sd">    sklearn.compose.make_column_selector : convenience function for selecting</span>
<span class="sd">        columns based on datatype or the columns name with a regex pattern.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.compose import ColumnTransformer</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.preprocessing import Normalizer</span>
<span class="sd">    &gt;&gt;&gt; ct = ColumnTransformer(</span>
<span class="sd">    ...     [(&quot;norm1&quot;, Normalizer(norm=&#39;l1&#39;), [0, 1]),</span>
<span class="sd">    ...      (&quot;norm2&quot;, Normalizer(norm=&#39;l1&#39;), slice(2, 4))])</span>
<span class="sd">    &gt;&gt;&gt; X = np.array([[0., 1., 2., 2.],</span>
<span class="sd">    ...               [1., 1., 0., 1.]])</span>
<span class="sd">    &gt;&gt;&gt; # Normalizer scales each row of X to unit norm. A separate scaling</span>
<span class="sd">    &gt;&gt;&gt; # is applied for the two first and two last elements of each</span>
<span class="sd">    &gt;&gt;&gt; # row independently.</span>
<span class="sd">    &gt;&gt;&gt; ct.fit_transform(X)</span>
<span class="sd">    array([[0. , 1. , 0.5, 0.5],</span>
<span class="sd">           [0.5, 0.5, 0. , 1. ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformers&#39;</span><span class="p">]</span>

    <span class="nd">@_deprecate_positional_args</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">transformers</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">remainder</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">,</span>
                 <span class="n">sparse_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transformer_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span> <span class="o">=</span> <span class="n">transformers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">remainder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_threshold</span> <span class="o">=</span> <span class="n">sparse_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformer_weights</span> <span class="o">=</span> <span class="n">transformer_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_transformers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal list of transformer only containing the name and</span>
<span class="sd">        transformers, dropping the columns. This is for the implementation</span>
<span class="sd">        of get_params via BaseComposition._get_params which expects lists</span>
<span class="sd">        of tuples of len 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">]</span>

    <span class="nd">@_transformers</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_transformers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
            <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get parameters for this estimator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : bool, default=True</span>
<span class="sd">            If True, will return the parameters for this estimator and</span>
<span class="sd">            contained subobjects that are estimators.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Parameter names mapped to their values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_params</span><span class="p">(</span><span class="s1">&#39;_transformers&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the parameters of this estimator.</span>

<span class="sd">        Valid parameter keys can be listed with ``get_params()``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_params</span><span class="p">(</span><span class="s1">&#39;_transformers&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replace_strings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate (name, trans, column, weight) tuples.</span>

<span class="sd">        If fitted=True, use the fitted transformers, else use the</span>
<span class="sd">        user specified transformers updated with converted column names</span>
<span class="sd">        and potentially appended with transformer for remainder.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fitted</span><span class="p">:</span>
            <span class="n">transformers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># interleave the validated column specifiers</span>
            <span class="n">transformers</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">column</span>
                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="c1"># add transformer tuple for remainder</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remainder</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">transformers</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">transformers</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_remainder</span><span class="p">])</span>
        <span class="n">get_weight</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer_weights</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">transformers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">replace_strings</span><span class="p">:</span>
                <span class="c1"># replace &#39;passthrough&#39; with identity transformer and</span>
                <span class="c1"># skip in case of &#39;drop&#39;</span>
                <span class="k">if</span> <span class="n">trans</span> <span class="o">==</span> <span class="s1">&#39;passthrough&#39;</span><span class="p">:</span>
                    <span class="n">trans</span> <span class="o">=</span> <span class="n">FunctionTransformer</span><span class="p">(</span>
                        <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_inverse</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">trans</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">_is_empty_column_selection</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
                    <span class="k">continue</span>

            <span class="k">yield</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">get_weight</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_validate_transformers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">names</span><span class="p">,</span> <span class="n">transformers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">)</span>

        <span class="c1"># validate names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_names</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="c1"># validate estimators</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transformers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;drop&#39;</span><span class="p">,</span> <span class="s1">&#39;passthrough&#39;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;fit_transform&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All estimators should implement fit and &quot;</span>
                                <span class="s2">&quot;transform, or can be &#39;drop&#39; or &#39;passthrough&#39; &quot;</span>
                                <span class="s2">&quot;specifiers. &#39;</span><span class="si">%s</span><span class="s2">&#39; (type </span><span class="si">%s</span><span class="s2">) doesn&#39;t.&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_validate_column_callables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts callable column specifications.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span> <span class="o">=</span> <span class="n">columns</span>

    <span class="k">def</span> <span class="nf">_validate_remainder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validates ``remainder`` and defines ``_remainder`` targeting</span>
<span class="sd">        the remaining columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_transformer</span> <span class="o">=</span> <span class="p">((</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remainder</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">)</span>
                           <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remainder</span><span class="p">,</span> <span class="s2">&quot;fit_transform&quot;</span><span class="p">))</span>
                          <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remainder</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remainder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;drop&#39;</span><span class="p">,</span> <span class="s1">&#39;passthrough&#39;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_transformer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The remainder keyword needs to be one of &#39;drop&#39;, &quot;</span>
                <span class="s2">&quot;&#39;passthrough&#39;, or estimator. &#39;</span><span class="si">%s</span><span class="s2">&#39; was passed instead&quot;</span> <span class="o">%</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remainder</span><span class="p">)</span>

        <span class="c1"># Make it possible to check for reordered named columns on transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_str_cols</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">_determine_key_type</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span>
                                 <span class="k">for</span> <span class="n">cols</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_df_columns</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">columns</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_get_column_indices</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span>

        <span class="n">remaining_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">cols</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remainder</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;remainder&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remaining_idx</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">named_transformers_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access the fitted transformer by name.</span>

<span class="sd">        Read-only attribute to access any transformer by given name.</span>
<span class="sd">        Keys are transformer names and values are the fitted transformer</span>
<span class="sd">        objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use Bunch object to improve autocomplete</span>
        <span class="k">return</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">trans</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">_</span>
                        <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers_</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">get_feature_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get feature names from all transformers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        feature_names : list of strings</span>
<span class="sd">            Names of the features produced by transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">fitted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">trans</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">trans</span> <span class="o">==</span> <span class="s1">&#39;passthrough&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_df_columns&#39;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">slice</span><span class="p">))</span>
                            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column</span><span class="p">)):</span>
                        <span class="n">feature_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_df_columns</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">)</span>
                    <span class="n">feature_names</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;x</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">column</span><span class="p">]])</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="s1">&#39;get_feature_names&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Transformer </span><span class="si">%s</span><span class="s2"> (type </span><span class="si">%s</span><span class="s2">) does not &quot;</span>
                                     <span class="s2">&quot;provide get_feature_names.&quot;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="n">feature_names</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span>
                                  <span class="n">trans</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">feature_names</span>

    <span class="k">def</span> <span class="nf">_update_fitted_transformers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformers</span><span class="p">):</span>
        <span class="c1"># transformers are fitted; excludes &#39;drop&#39; cases</span>
        <span class="n">fitted_transformers</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">transformers</span><span class="p">)</span>
        <span class="n">transformers_</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">old</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span><span class="p">:</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="s1">&#39;drop&#39;</span>
            <span class="k">elif</span> <span class="n">old</span> <span class="o">==</span> <span class="s1">&#39;passthrough&#39;</span><span class="p">:</span>
                <span class="c1"># FunctionTransformer is present in list of transformers,</span>
                <span class="c1"># so get next transformer, but save original string</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">fitted_transformers</span><span class="p">)</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="s1">&#39;passthrough&#39;</span>
            <span class="k">elif</span> <span class="n">_is_empty_column_selection</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">old</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">fitted_transformers</span><span class="p">)</span>
            <span class="n">transformers_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span>

        <span class="c1"># sanity check that transformers is exhausted</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">(</span><span class="n">fitted_transformers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformers_</span> <span class="o">=</span> <span class="n">transformers_</span>

    <span class="k">def</span> <span class="nf">_validate_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that the output of each transformer is 2D. Otherwise</span>
<span class="sd">        hstack can raise an error or produce incorrect results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">fitted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                      <span class="n">replace_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">Xs</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The output of the &#39;</span><span class="si">{0}</span><span class="s2">&#39; transformer should be 2D (scipy &quot;</span>
                    <span class="s2">&quot;matrix, array, or pandas DataFrame).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_validate_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_features</span><span class="p">,</span> <span class="n">feature_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensures feature counts and names are the same during fit and</span>
<span class="sd">        transform.</span>

<span class="sd">        TODO: It should raise an error from v0.24</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_names_in</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">feature_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">==</span> <span class="n">n_features</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">neg_col_present</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">_is_negative_indexing</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">neg_col_present</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">!=</span> <span class="n">n_features</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;At least one negative column was used to &quot;</span>
                               <span class="s2">&quot;indicate columns, and the new data&#39;s number &quot;</span>
                               <span class="s2">&quot;of columns does not match the data given &quot;</span>
                               <span class="s2">&quot;during fit. &quot;</span>
                               <span class="s2">&quot;Please make sure the data during fit and &quot;</span>
                               <span class="s2">&quot;transform have the same number of columns.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">!=</span> <span class="n">n_features</span> <span class="ow">or</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature_names_in</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">feature_names</span><span class="p">))):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Given feature/column names or counts do not match &quot;</span>
                          <span class="s2">&quot;the ones for the data given during fit. This will &quot;</span>
                          <span class="s2">&quot;fail from v0.24.&quot;</span><span class="p">,</span>
                          <span class="ne">FutureWarning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_log_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%d</span><span class="s1"> of </span><span class="si">%d</span><span class="s1">) Processing </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fitted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private function to fit and/or transform on demand.</span>

<span class="sd">        Return value (transformers and/or transformed X data) depends</span>
<span class="sd">        on the passed function.</span>
<span class="sd">        ``fitted=True`` ensures the fitted transformers are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">fitted</span><span class="o">=</span><span class="n">fitted</span><span class="p">,</span> <span class="n">replace_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span>
                    <span class="n">transformer</span><span class="o">=</span><span class="n">clone</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">fitted</span> <span class="k">else</span> <span class="n">trans</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">_safe_indexing</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                    <span class="n">message_clsname</span><span class="o">=</span><span class="s1">&#39;ColumnTransformer&#39;</span><span class="p">,</span>
                    <span class="n">message</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_message</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformers</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_iter</span><span class="p">(</span><span class="n">fitted</span><span class="o">=</span><span class="n">fitted</span><span class="p">,</span> <span class="n">replace_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Expected 2D array, got 1D array instead&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_ERR_MSG_1DCOLUMN</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit all transformers using X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, dataframe} of shape (n_samples, n_features)</span>
<span class="sd">            Input data, of which specified subsets are used to fit the</span>
<span class="sd">            transformers.</span>

<span class="sd">        y : array-like of shape (n_samples,...), default=None</span>
<span class="sd">            Targets for supervised learning.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : ColumnTransformer</span>
<span class="sd">            This estimator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we use fit_transform to make sure to set sparse_output_ (for which we</span>
        <span class="c1"># need the transformed data) to have consistent output type in predict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit all transformers, transform the data and concatenate results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, dataframe} of shape (n_samples, n_features)</span>
<span class="sd">            Input data, of which specified subsets are used to fit the</span>
<span class="sd">            transformers.</span>

<span class="sd">        y : array-like of shape (n_samples,), default=None</span>
<span class="sd">            Targets for supervised learning.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_t : {array-like, sparse matrix} of \</span>
<span class="sd">                shape (n_samples, sum_n_components)</span>
<span class="sd">            hstack of results of transformers. sum_n_components is the</span>
<span class="sd">            sum of n_components (output dimension) over transformers. If</span>
<span class="sd">            any result is a sparse matrix, everything will be converted to</span>
<span class="sd">            sparse matrices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: this should be `feature_names_in_` when we start having it</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_feature_names_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_feature_names_in</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_check_X</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># set n_features_in_ attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_n_features</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_transformers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_column_callables</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_remainder</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_fit_transform_one</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_fitted_transformers</span><span class="p">([])</span>
            <span class="c1"># All transformers are None</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">Xs</span><span class="p">,</span> <span class="n">transformers</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># determine if concatenated output will be sparse or not</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">Xs</span><span class="p">):</span>
            <span class="n">nnz</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">nnz</span> <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">else</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">Xs</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">Xs</span><span class="p">)</span>
            <span class="n">density</span> <span class="o">=</span> <span class="n">nnz</span> <span class="o">/</span> <span class="n">total</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse_output_</span> <span class="o">=</span> <span class="n">density</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_threshold</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse_output_</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_fitted_transformers</span><span class="p">(</span><span class="n">transformers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_output</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Xs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform X separately by each transformer, concatenate results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, dataframe} of shape (n_samples, n_features)</span>
<span class="sd">            The data to be transformed by subset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_t : {array-like, sparse matrix} of \</span>
<span class="sd">                shape (n_samples, sum_n_components)</span>
<span class="sd">            hstack of results of transformers. sum_n_components is the</span>
<span class="sd">            sum of n_components (output dimension) over transformers. If</span>
<span class="sd">            any result is a sparse matrix, everything will be converted to</span>
<span class="sd">            sparse matrices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_check_X</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">):</span>
            <span class="n">X_feature_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X_feature_names</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of features of the input must be equal &#39;</span>
                             <span class="s1">&#39;to or greater than that of the fitted &#39;</span>
                             <span class="s1">&#39;transformer. Transformer n_features is </span><span class="si">{0}</span><span class="s1"> &#39;</span>
                             <span class="s1">&#39;and input n_features is </span><span class="si">{1}</span><span class="s1">.&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_features</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># No column reordering allowed for named cols combined with remainder</span>
        <span class="c1"># TODO: remove this mechanism in 0.24, once we enforce strict column</span>
        <span class="c1"># name order and count. See #14237 for details.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_remainder</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_df_columns&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_str_cols</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">)):</span>
            <span class="n">n_cols_fit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_df_columns</span><span class="p">)</span>
            <span class="n">n_cols_transform</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n_cols_transform</span> <span class="o">&gt;=</span> <span class="n">n_cols_fit</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">[:</span><span class="n">n_cols_fit</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df_columns</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Column ordering must be equal for fit &#39;</span>
                                 <span class="s1">&#39;and for transform when using the &#39;</span>
                                 <span class="s1">&#39;remainder keyword&#39;</span><span class="p">)</span>

        <span class="c1"># TODO: also call _check_n_features(reset=False) in 0.24</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_features</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">X_feature_names</span><span class="p">)</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_transform_one</span><span class="p">,</span> <span class="n">fitted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_output</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">Xs</span><span class="p">:</span>
            <span class="c1"># All transformers are None</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Xs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_hstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stacks Xs horizontally.</span>

<span class="sd">        This allows subclasses to control the stacking behavior, while reusing</span>
<span class="sd">        everything else from ColumnTransformer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xs : list of {array-like, sparse matrix, dataframe}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_output_</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># since all columns should be numeric before stacking them</span>
                <span class="c1"># in a sparse matrix, `check_array` is used for the</span>
                <span class="c1"># dtype conversion if necessary.</span>
                <span class="n">converted_Xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span>
                                            <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">force_all_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">Xs</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For a sparse output, all columns should&quot;</span>
                                 <span class="s2">&quot; be a numeric or convertible to a numeric.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">converted_Xs</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">else</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">Xs</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sk_visual_block_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">names</span><span class="p">,</span> <span class="n">transformers</span><span class="p">,</span> <span class="n">name_details</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_VisualBlock</span><span class="p">(</span><span class="s1">&#39;parallel&#39;</span><span class="p">,</span> <span class="n">transformers</span><span class="p">,</span>
                            <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">name_details</span><span class="o">=</span><span class="n">name_details</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_X</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use check_array only on lists and other non-array-likes / sparse&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s1">&#39;__array__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">X</span>
    <span class="k">return</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">force_all_finite</span><span class="o">=</span><span class="s1">&#39;allow-nan&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_empty_column_selection</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the column selection is empty (empty list or all-False</span>
<span class="sd">    boolean array).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">column</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_get_transformer_list</span><span class="p">(</span><span class="n">estimators</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct (name, trans, column) tuples from list</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transformers</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">estimators</span><span class="p">)</span>
    <span class="n">names</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">_name_estimators</span><span class="p">(</span><span class="n">transformers</span><span class="p">))</span>

    <span class="n">transformer_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">transformers</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">transformer_list</span>


<span class="k">def</span> <span class="nf">make_column_transformer</span><span class="p">(</span><span class="o">*</span><span class="n">transformers</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a ColumnTransformer from the given transformers.</span>

<span class="sd">    This is a shorthand for the ColumnTransformer constructor; it does not</span>
<span class="sd">    require, and does not permit, naming the transformers. Instead, they will</span>
<span class="sd">    be given names automatically based on their types. It also does not allow</span>
<span class="sd">    weighting with ``transformer_weights``.</span>

<span class="sd">    Read more in the :ref:`User Guide &lt;make_column_transformer&gt;`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *transformers : tuples</span>
<span class="sd">        Tuples of the form (transformer, columns) specifying the</span>
<span class="sd">        transformer objects to be applied to subsets of the data.</span>

<span class="sd">        transformer : {&#39;drop&#39;, &#39;passthrough&#39;} or estimator</span>
<span class="sd">            Estimator must support :term:`fit` and :term:`transform`.</span>
<span class="sd">            Special-cased strings &#39;drop&#39; and &#39;passthrough&#39; are accepted as</span>
<span class="sd">            well, to indicate to drop the columns or to pass them through</span>
<span class="sd">            untransformed, respectively.</span>
<span class="sd">        columns : str,  array-like of str, int, array-like of int, slice, \</span>
<span class="sd">                array-like of bool or callable</span>
<span class="sd">            Indexes the data on its second axis. Integers are interpreted as</span>
<span class="sd">            positional columns, while strings can reference DataFrame columns</span>
<span class="sd">            by name. A scalar string or int should be used where</span>
<span class="sd">            ``transformer`` expects X to be a 1d array-like (vector),</span>
<span class="sd">            otherwise a 2d array will be passed to the transformer.</span>
<span class="sd">            A callable is passed the input data `X` and can return any of the</span>
<span class="sd">            above. To select multiple columns by name or dtype, you can use</span>
<span class="sd">            :obj:`make_column_selector`.</span>

<span class="sd">    remainder : {&#39;drop&#39;, &#39;passthrough&#39;} or estimator, default=&#39;drop&#39;</span>
<span class="sd">        By default, only the specified columns in `transformers` are</span>
<span class="sd">        transformed and combined in the output, and the non-specified</span>
<span class="sd">        columns are dropped. (default of ``&#39;drop&#39;``).</span>
<span class="sd">        By specifying ``remainder=&#39;passthrough&#39;``, all remaining columns that</span>
<span class="sd">        were not specified in `transformers` will be automatically passed</span>
<span class="sd">        through. This subset of columns is concatenated with the output of</span>
<span class="sd">        the transformers.</span>
<span class="sd">        By setting ``remainder`` to be an estimator, the remaining</span>
<span class="sd">        non-specified columns will use the ``remainder`` estimator. The</span>
<span class="sd">        estimator must support :term:`fit` and :term:`transform`.</span>

<span class="sd">    sparse_threshold : float, default=0.3</span>
<span class="sd">        If the transformed output consists of a mix of sparse and dense data,</span>
<span class="sd">        it will be stacked as a sparse matrix if the density is lower than this</span>
<span class="sd">        value. Use ``sparse_threshold=0`` to always return dense.</span>
<span class="sd">        When the transformed output consists of all sparse or all dense data,</span>
<span class="sd">        the stacked result will be sparse or dense, respectively, and this</span>
<span class="sd">        keyword will be ignored.</span>

<span class="sd">    n_jobs : int, default=None</span>
<span class="sd">        Number of jobs to run in parallel.</span>
<span class="sd">        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.</span>
<span class="sd">        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`</span>
<span class="sd">        for more details.</span>

<span class="sd">    verbose : bool, default=False</span>
<span class="sd">        If True, the time elapsed while fitting each transformer will be</span>
<span class="sd">        printed as it is completed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ct : ColumnTransformer</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.compose.ColumnTransformer : Class that allows combining the</span>
<span class="sd">        outputs of multiple transformer objects used on column subsets</span>
<span class="sd">        of the data into a single feature space.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.compose import make_column_transformer</span>
<span class="sd">    &gt;&gt;&gt; make_column_transformer(</span>
<span class="sd">    ...     (StandardScaler(), [&#39;numerical_column&#39;]),</span>
<span class="sd">    ...     (OneHotEncoder(), [&#39;categorical_column&#39;]))</span>
<span class="sd">    ColumnTransformer(transformers=[(&#39;standardscaler&#39;, StandardScaler(...),</span>
<span class="sd">                                     [&#39;numerical_column&#39;]),</span>
<span class="sd">                                    (&#39;onehotencoder&#39;, OneHotEncoder(...),</span>
<span class="sd">                                     [&#39;categorical_column&#39;])])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># transformer_weights keyword is not passed through because the user</span>
    <span class="c1"># would need to know the automatically generated names of the transformers</span>
    <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_jobs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;remainder&#39;</span><span class="p">,</span> <span class="s1">&#39;drop&#39;</span><span class="p">)</span>
    <span class="n">sparse_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sparse_threshold&#39;</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unknown keyword arguments: &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">transformer_list</span> <span class="o">=</span> <span class="n">_get_transformer_list</span><span class="p">(</span><span class="n">transformers</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ColumnTransformer</span><span class="p">(</span><span class="n">transformer_list</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                             <span class="n">remainder</span><span class="o">=</span><span class="n">remainder</span><span class="p">,</span>
                             <span class="n">sparse_threshold</span><span class="o">=</span><span class="n">sparse_threshold</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_negative_indexing</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="c1"># TODO: remove in v0.24</span>
    <span class="k">def</span> <span class="nf">is_neg</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">is_neg</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_neg</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_determine_key_type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">make_column_selector</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a callable to select columns to be used with</span>
<span class="sd">    :class:`ColumnTransformer`.</span>

<span class="sd">    :func:`make_column_selector` can select columns based on datatype or the</span>
<span class="sd">    columns name with a regex. When using multiple selection criteria, **all**</span>
<span class="sd">    criteria must match for a column to be selected.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pattern : str, default=None</span>
<span class="sd">        Name of columns containing this regex pattern will be included. If</span>
<span class="sd">        None, column selection will not be selected based on pattern.</span>

<span class="sd">    dtype_include : column dtype or list of column dtypes, default=None</span>
<span class="sd">        A selection of dtypes to include. For more details, see</span>
<span class="sd">        :meth:`pandas.DataFrame.select_dtypes`.</span>

<span class="sd">    dtype_exclude : column dtype or list of column dtypes, default=None</span>
<span class="sd">        A selection of dtypes to exclude. For more details, see</span>
<span class="sd">        :meth:`pandas.DataFrame.select_dtypes`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    selector : callable</span>
<span class="sd">        Callable for column selection to be used by a</span>
<span class="sd">        :class:`ColumnTransformer`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    sklearn.compose.ColumnTransformer : Class that allows combining the</span>
<span class="sd">        outputs of multiple transformer objects used on column subsets</span>
<span class="sd">        of the data into a single feature space.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.compose import make_column_transformer</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.compose import make_column_selector</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; X = pd.DataFrame({&#39;city&#39;: [&#39;London&#39;, &#39;London&#39;, &#39;Paris&#39;, &#39;Sallisaw&#39;],</span>
<span class="sd">    ...                   &#39;rating&#39;: [5, 3, 4, 5]})  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; ct = make_column_transformer(</span>
<span class="sd">    ...       (StandardScaler(),</span>
<span class="sd">    ...        make_column_selector(dtype_include=np.number)),  # rating</span>
<span class="sd">    ...       (OneHotEncoder(),</span>
<span class="sd">    ...        make_column_selector(dtype_include=object)))  # city</span>
<span class="sd">    &gt;&gt;&gt; ct.fit_transform(X)  # doctest: +SKIP</span>
<span class="sd">    array([[ 0.90453403,  1.        ,  0.        ,  0.        ],</span>
<span class="sd">           [-1.50755672,  1.        ,  0.        ,  0.        ],</span>
<span class="sd">           [-0.30151134,  0.        ,  1.        ,  0.        ],</span>
<span class="sd">           [ 0.90453403,  0.        ,  0.        ,  1.        ]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@_deprecate_positional_args</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype_include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dtype_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype_include</span> <span class="o">=</span> <span class="n">dtype_include</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype_exclude</span> <span class="o">=</span> <span class="n">dtype_exclude</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;make_column_selector can only be applied to &quot;</span>
                             <span class="s2">&quot;pandas dataframes&quot;</span><span class="p">)</span>
        <span class="n">df_row</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_row</span> <span class="o">=</span> <span class="n">df_row</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_include</span><span class="p">,</span>
                                          <span class="n">exclude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_exclude</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">df_row</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">cols</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">cols</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../../_static/js/index.d3f166471bb80abb5163.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2021, Boston Consulting Group (BCG).<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.4.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>